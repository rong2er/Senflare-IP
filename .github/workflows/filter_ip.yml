name: Filter Proxy List by Tag

on:
  schedule:
    - cron: '0 2 * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  filter-proxies:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Install dependencies
      run: pip install requests

    - name: Run Filter & TCP-Check Script
      env:
        SOURCE_URL: 'https://zip.cm.edu.kg/all.txt'
      run: |
        cat <<EOF > filter.py
        import requests
        import os
        import socket
        import concurrent.futures

        # 1. 定义筛选地区
        TARGET_TAGS = ["#HK", "#TW", "#JP", "#KR", "#SG"]

        # 2. TCP 端口检测函数 (比 Ping 更准)
        def check_port(line):
            try:
                # 预处理：分离标签，保留 "IP:端口"
                # 例如 "8.8.8.8:443#HK" -> content="8.8.8.8:443"
                content = line.split('#')[0].strip()
                
                # 分离 IP 和 端口
                # 使用 rsplit 确保即使是 IPv6 也能正确切分最后一个冒号
                if ':' not in content: return None
                ip_str, port_str = content.rsplit(':', 1)
                
                # 去除 IPv6 可能带的方括号 []
                ip = ip_str.replace('[', '').replace(']', '')
                port = int(port_str)

                # 建立 TCP 连接尝试
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(2) # 2秒超时，连不上就算死
                    s.connect((ip, port))
                
                # 如果没报错，说明连通了，返回原行
                return line
            except:
                return None

        def main():
            url = os.environ.get('SOURCE_URL')
            print(f"1. 正在下载列表: {url}")
            
            try:
                resp = requests.get(url, timeout=30)
                resp.raise_for_status()
                all_lines = resp.text.splitlines()
                
                # --- 标签筛选 ---
                tag_filtered = []
                for line in all_lines:
                    line = line.strip()
                    if not line: continue
                    if any(tag in line.upper() for tag in TARGET_TAGS):
                        tag_filtered.append(line)
                
                # 去重
                tag_filtered = sorted(list(set(tag_filtered)))
                print(f"2. 标签筛选完成，剩余 {len(tag_filtered)} 个候选节点，开始 TCP 端口检测...")
                
                if not tag_filtered:
                    print("警告：没有找到符合标签的节点。")
                    exit(0)

                # --- 并发 TCP 检测 ---
                alive_lines = []
                # TCP 连接耗时较短，可以开更多线程 (100并发)
                with concurrent.futures.ThreadPoolExecutor(max_workers=100) as executor:
                    futures = [executor.submit(check_port, line) for line in tag_filtered]
                    
                    for future in concurrent.futures.as_completed(futures):
                        result = future.result()
                        if result:
                            alive_lines.append(result)
                            if len(alive_lines) % 10 == 0:
                                print(f"  -> 已确认 {len(alive_lines)} 个端口连通...")

                print(f"3. 检测完成！存活: {len(alive_lines)} / 原有: {len(tag_filtered)}")
                
                # 保存结果
                with open('asian_ip.txt', 'w', encoding='utf-8') as f:
                    f.write('\n'.join(alive_lines))
                    
            except Exception as e:
                print(f"发生错误: {e}")
                exit(1)

        if __name__ == '__main__':
            main()
        EOF
        
        python filter.py

    - name: Commit and Push results
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add asian_ip.txt
        git commit -m "Auto update Asian IPs: $(date +'%Y-%m-%d')" || exit 0
        git push
